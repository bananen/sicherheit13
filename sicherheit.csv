Frontside,Flipside,Category,Level
Stromchiffre,Spuckt mit Hilfe eines Schluessels und einer geeigneten Funktion nach und nach ein pseudozufaelliges OTP aus,Sicherheit,0
Blockchiffre,"Funktion bildet Schluessel und Klartextblock auf Chiffratblock ab, es gibt mehrere Betriebsmodi",Sicherheit,0
Electronic Codebook (ECB) Mode,"Jeder Nachrichtenblock wird einzeln auf ein Chiffratblock abgebildet, gleiche Nachrichtenbloecke werden somit auf gleich Chiffratbloecke abgebildet",Sicherheit,0
Cipher Block Chaining (CBC) Mode,"Teile M in l-Bit-Bloecke auf
C<sub>0</sub> := IV
C<sub>i</sub> := E(K, M<sub>i</sub> xor C<sub>i-1</sub>)
Entschluesselung: M<sub>i</sub> := D(K, C<sub>i</sub>) xor C<sub>i-1</sub>",Sicherheit,0
Cipher Feedback (CFB) Mode,"C<sub>i</sub> := E(K, C<sub>i-1</sub>) xor M<sub>i</sub>",Sicherheit,0
Output Feedback (OFB) Mode,"C<sub>i</sub> := E(K, D<sub>i-1</sub>) xor M<sub>i</sub>
D<sub>i</sub> := E(K, K<sub>i-1</sub>)",Sicherheit,0
Data Encryption Standard (DES),"verwendet Feistel-Netzwerke
verwendet Rundenfunktion F ohne Falltuer -&gt; Falltuerfunktion E",Sicherheit,0
DES-Rundenfunktion F,,Sicherheit,0
DES-Feistelstruktur,,Sicherheit,0
Meet-in-the-Middle-Angriff auf 2DES,"Gegeben: Nachricht-Chiffrat-Paar, gesucht: K = (K<sub>1</sub>, K<sub>2</sub>)
Verschluessel M mit allen moeglichen Schluesseln, sortiere, entschluessel C mit allen moeglichen Schluesseln und vergleiche mit sortierter Liste",Sicherheit,0
Lineare Kryptoanalyse,"Finde F<sub>2</sub>-lineare Abhaengigkeiten zwischen den Bits
idealer Fall: K aus Paaren herleitbar
bei Feistelverfahren indirekter Angriff moeglich:
1. Finde lin. Abh. zwischen F-Ein- und -Ausgabe
2. Erweitere Abhaengigkeiten auf die ersten n-1 Feistel-Runden
3. Vollstaendige Suche ueber letzten Rundenschluessel K<sup>(n)</sup>...
4. ...ueberpruefe K<sup>(n)</sup>-Kandidaten mittel linearer Abhaengigkeit
5. Wenn K<sup>(n)</sup> gefunden, suche nach K<sup>(n-1)</sup>, danach K<sup>(n-2)</sup>",Sicherheit,0
Differentielle Kryptoanalyse,"Betrachte Ausgabedifferenzen in Abhaengigkeit von Eingabedifferenzen
Bei Feistel-Verfahren aehnlich wie bei lin. Analyse:
1. Finde wahrscheinliche Paare von Differenzen zwischen Ein- und Ausgabe von vorletzter Runde
2. Vollstaendige Suche ueber letzten Rundenschluessel K<sup>(n)</sup>...
3. ...ueberpruefe K<sup>(n)</sup>-Kandidaten auf Differenzen-Konsistenz aus 1",Sicherheit,0
Semantische Sicherheit,"Ein symmetrisches Verschluesselungsverfahren ist semantisch sicher, wenn es fuer jede M-Verteilung von Nachrichten gleicher Laenge, jede Funktion f und jeden effizienten Algorithmus A einen effizienten Algorithmus B gibt, sodass

Pr[A<sup>Enc(K,.)</sup>(Enc(K,M)) = f(M)] - Pr[B(e) = f(M)]

klein ist",Sicherheit,0
IND-CPA (indistinguishability under chosen-plaintext attacks),"kein effizienter Angreifer A kann Chriffrate von selbstgewaehlten Klartexten unterscheiden:
1. A erhaelt Zugriff auf Enc(K,.)-Orakel
2. A waehlt zwei Nachrichten M<sup>(1)</sup>, M<sup>(2)</sup> gleicher Laenge
3. A erhaelt C<sup>*</sup> := Enc(K, M<sup>(b)</sup>) fuer gleichverteiltes b in {1, 2}
4. A gewinnt, wenn es b richtig raet

forall A: (Pr[A gewinnt] - 0.5) klein :&lt;=&gt; Schema IND-CPA-sicher
Ein symmetrisches Verschluesselungsverfahren ist genau dann semantisch sicher, wenn es IND-CPA sicher ist",Sicherheit,0
Kollisionsresistenz von Hashfunktionen,"Eine Hashfunktion H ist kollisionsresistent, wenn jeder effiziente Algorithmus nur mit kleiner Wahrscheinlichkeit eine Kollision findet

formal:
Eine ueber k parametrisierte Funktion H ist kollisionsresistent, wenn jeder PPT-Algorithmus nur mit hoechstens vernachlaessigbarer Wahrscheinlichkeit eine Kollision findet.
Genauer: fuer jeden PPT-Algorithmus A ist

Adv<sup>cr</sup><sub>H,A</sub>(k) := Pr[(X, X') &lt;- A(1<sup>k</sup>) : X != X' und H<sub>k</sub>(X) = H<sub>k</sub>(X')]

vernachlaessigbar

Kollisionsresistenz =&gt; Einwegeigenschaft",Sicherheit,0
Effizienz,"Polynomialzeit (in k), also ein Algorithmus, welcher Kollision durch vollstaendige Suche aller X in {0, 1}<sup>k+1</sup> findet, ist nicht effizient",Sicherheit,0
kleine Wahrscheinlichkeit,"vernachlaessigbar (in k)
f: N -&gt; R vernachlaessigbar :&lt;=&gt; |f| verschwindet asymptotisch schneller als Kehrwert jedes vorgegebenen Polynoms",Sicherheit,0
Einwegfunktion,"Eine ueber k parametrisierte Funktion H ist eine Einwegfunktion bzgl. der Urbildverteilung, wenn jeder PPT-Algorithmus nur mit hoechstens vernachlaessigbarer Wahrscheinlichkeit ein Urbild eines gegebenen, aus der Urbildverteilung gezogenen Bildes findet.
Genauer: fuer jeden PPT-Algorithmus A ist

Adv<sup>ow</sup><sub>H,A</sub>(k) := Pr[X' &lt;- A(1<sup>k</sup>, H(X)) : H(X) = H(X')]

vernachlaessigbar, wobei X &lt;- Urbildmenge gewaehlt wurde",Sicherheit,0
Target Collision Resistance (weniger wichtig) bzw. Second Preimage Resistance oder Universal One-Way,"Gegeben X, finde X' mit H(X) = H(X')

Kollisionsresistenz =&gt; Target Collision Resistance =&gt; Einwegeigenschaft",Sicherheit,0
Merkle-Damgard-Konstruktion,"Hashfunktion H<sub>MD</sub> wird aus einfachen Bausteinen gebaut
Baustein: Kompressionsfunktion F: {0, 1}<sup>2k</sup> -&gt; {0, 1}<sup>k

</sup>
Ist F kollisionsresistent, so ist auch H<sub>MD</sub> kollisionsresistent",Sicherheit,0
Birthday Attack,"Birthday Bound Theorem:
Sei n &lt; 2<sup>k/2</sup> und Y<sub>1</sub>,...,Y<sub>n</sub> in {0, 1}<sup>k</sup> unabhaengig gleichverteilt. Dann gibt es i != j mit Y<sub>i</sub> = Y<sub>j</sub> mit Wkt. p &gt; (1/11) * (n<sup>2</sup>/2<sup>k</sup>)

Konsequenz: fuer n = 2<sup>k/2</sup> zufaellige (verschiedene) X<sub>i</sub> Kollisionen unter den Y<sub>i</sub> mit Wahrscheinlichkeit p &gt; 1/11

Also Ausgabelaenge &gt;= k Bits fuer k/2 Bits Sicherheit",Sicherheit,0
RSA,"pk = (N,e); sk = (N,d)

N = PQ fuer (hinreichend große) Primzahlen P != Q
Rechnung in Z/NZ
e und d sind zueinenander inverse Exponenten:
e * d = 1 mod (P-1)(Q-1)

Enc(pk, M) = M<sup>e</sup> mod N; Dec(sk, C) = C<sup>d</sup> mod N

RSA ist homomorph, daher verfaelschende Angriffe moeglich",Sicherheit,0
Semantische Sicherheit fuer Public-Key-Verfahren,"Ein Public-Key-Verschluesselungsschema ist semantisch sicher, wenn es fuer jede M-Verteilung von Nachrichten gleicher Laenge jede Funktion f und jeden PPT-Algorithmus A einen PPT-Algorithmus B gibt, sodass

Pr[A(1<sup>k</sup>, pk, Enc(pk, M)) = f(M)] - Pr[B(1<sup>k</sup>) = f(M)]

vernachlaessigbar ist

Aequivalent zu IND-CPA",Sicherheit,0
ElGamal,"zyklische Gruppe G = &lt;g&gt;
pk = (G, g, g<sup>x</sup>), sk = (G,g,x) (mit x zufaellig)
End(pk, M) = (g<sup>y</sup>, g<sup>xy</sup> * M) (mit y zufaellig)
Dec(sk, (Y, Z)) = Z/Y<sup>x</sup> (= (g<sup>xy</sup> * M)/(g<sup>y</sup>)<sup>x</sup> = M)

Verschluesselung probabilistisch, aber wie RSA homomorph",Sicherheit,0
MAC (Message Authentication Code),"Signieren: sigma &lt;- Sig(K, M)
Verifizieren: Ver(K, M, sigma) in {0, 1}
Korrektheit: Ver(K, sigma) = 1 fuer alle K, M und sigma &lt;- Sig(K, M)",Sicherheit,0
EUF-CMA,"Schema EUF-CMA-sicher &lt;=&gt; kein PPT-Angreifer A gewinnt folgendes Spiel nicht-vernachlaessigbar oft:
1. A erhaelt Zugriff auf ein Sig(K, .)-Orakel
2. A gibt Ausgabe (M<sup>*</sup>, sigma<sup>*</sup>)
3. A gewinnt, wenn Ver(K, M<sup>*</sup>, sigma<sup>*</sup>) = 1 und M<sup>*</sup> ""frisch""",Sicherheit,0
Hash-Then-Sign-Paradigma,"Sei (Sig, Ver) EUF-CMA-sicher und H eine kollisionsresistente Hashfunktion. Dann ist der durch Sig'(K, M) = Sig(K, H(M)), Ver'(K, M, sigma) = Ver(K, H(M), sigma) erklaerte MAC EUF-CMA-sicher",Sicherheit,0
Pseudorandom Function,"Sei PRF: {0, 1}<sup>k</sup> x {0, 1}<sup>k</sup> -&gt; {0, 1}<sup>k</sup> eine ueber k in N paramentrisierte Funktion. PRF heißt Pseudorandom Function (PRF), falls fuer jeden PPT-Algorithmus A die Funktion

Adv<sup>prf</sup><sub>PRF,A</sub>(k) := Pr[A<sup>PRF(K,.)</sup>(1<sup>k</sup>) = 1] - Pr[A<sup>R(.)</sup>(1<sup>k</sup>) = 1]

vernachlaessigbar ist, wobei R: {0, 1}<sup>k</sup> -&gt; {0, 1}<sup>k</sup> eine echt zufaellige Funktion ist",Sicherheit,0
MACs aus PRFs und Hashfunktionen,"Sei PRF: {0, 1}<sup>k</sup> x {0, 1}<sup>k</sup> -&gt; {0, 1}<sup>k</sup> eine PRF und H: {0, 1}* -&gt; {0, 1}<sup>k</sup> eine kollisionsresistente Hashfunktion. Dann ist der durch Sig(K, M) = PRF(K, H(M)) gegebene MAC EUF-CMA-sicher.

Unsicher: Sig(K, M) = H(K, M)
Besser: Sig(K, M) = H(K, H(M))
HMAC, noch besser: Sig(K, M) = H(K xor opad, H(K xor ipad, M))",Sicherheit,0
Digitale Signarturschemata,"(pk, sk) &lt;- Gen(1<sup>k</sup>)

Signieren: sigma &lt;- Sig(sk, M)
Verifizieren: Ver(pk, M, sigma) in {0, 1}

Korrektheit wie bei MACs: Ver(pk, M, sigma) = 1 fuer alle (pk, sk) &lt;- Gen(1<sup>k</sup>), alle M und alle sigma = Sig(sk, M)

Schema EUF-CMA-sicher &lt;=&gt; kein PPT-Angreifer A gewinnt folgendes Spiel nicht-vernachlaessigbar oft:
1. A erhaelt Zugriff auf ein Sig(sk, .)-Orakel
2. A gibt Ausgabe (M<sup>*</sup>, sigma<sup>*</sup>)
3. A gewinnt, wenn Ver(pk, M<sup>*</sup>, sigma<sup>*</sup>) = 1 und M<sup>*</sup> 'frisch'",Sicherheit,0
RSA als Signaturschema,"Sig(sk, M) = M<sup>d</sup> mod N
Ver(pk, M, sigma) = 1 :&lt;=&gt; M = sigma<sup>e</sup> mod N

Problem: unsinnige Nachrichten koennen signiert werden:
1. Waehle Signatur sigma beliebig
2. Setze M := sigma<sup>e</sup> mod N

Problem: Homomorphie von RSA: Neue Signaturen lassen sich aus bekannten berechnen

Bricht beides EUF-CMA-Sicherheit

Loesung: RSA-PSS",Sicherheit,0
RSA-PSS (Probabilistic Signature Scheme),"Sig(sk, M) = (pad(M))<sup>d</sup> mod N
Ver(pk, M, sigma) = 1 :&lt;=&gt; sigma<sup>e</sup> mod N gueltiges pad(M)

EUF-CMA-sicher, sofern RSA-Funktion schwer zu invertieren
Teil von PKCS#1",Sicherheit,0
ElGamal-Signaturen,"Ueber zyklischer Gruppe G = &lt;g&gt;

pk = (G, g, g<sup>x</sup>), sk = (G, g, x)

Erster Versuch:
Sig(sk, M) = a mit a * x = M mod |G|
Ver(pk, M, sigma) = 1 :&lt;=&gt; (g<sup>x</sup>)<sup>a</sup> = g<sup>M

</sup>Zweiter Versuch (ElGamal-Signaturen):
a := g<sup>e</sup> fuer zufaelliges e
b als Loesung von a * x + e * b = M mod |G|
Sig(sk, M) = (a, b)
Ver(pk, M, sigma) = 1 :&lt;=&gt; (g<sup>x</sup>)<sup>a</sup>a<sup>b</sup> = g<sup>M</sup>

a = g<sup>e</sup> wird sowohl als G-Element als auch als Exponent interpretiert

Problem: Nicht EUF-CMA-sicher weil Signaturen fuer unsinnige Nachrichten erstellt werden koennen",Sicherheit,0
Hash-Then-Sign-Paradigma,"Sei (Gen, Sig, Ver) EUF-CMA-sicher und H eine kollisionsresistente Hashfunktion. Dann ist das durch 

Gen'(1<sup>k</sup>) = Gen(1<sup>k</sup>)
Sig'(sk, M) = Sig(sk, H(M))
Ver'(pk, M, sigma) = Ver(pk, H(M), sigma)

erklaerte Signatureverfahren EUF-CMA-sicher",Sicherheit,0
Digital Signatures Algorithm (DSA),"sigma = (a = g<sup>e</sup>, b) mit
a*x + e*b = H(M) mod |G|

EUF-CMA-Sicherheit unklar",Sicherheit,0
Kerberos,"Symmetrisches Schluesselaustauschprotokoll
Arbeitet mit Keycenter

Alice --- (Alice, Bob) ---&gt; KC
KC    --- Enc(K<sub>A</sub>,(T<sub>KC</sub>,L,K,Bob)), Enc(K<sub>B</sub>,(T<sub>KC</sub>,L,K,Bob)) ---&gt; Alice
Alice --- Enc(K,(Alice,T<sub>A</sub>)), Enc(K<sub>B</sub>,(T<sub>KC</sub>,L,K,Bob)) ---&gt; Bob
Bob  --- Enc(K, T<sub>A</sub>+1) ---&gt; Alice

Keine Man-in-the-middle- und Replay-Angriffe, aber aktiv sichere Verschluesselung noetig, Sicherheit nicht formal geklaert",Sicherheit,0
Public-Key Transport,"Basisverfahren:
Alice --- Enc(pk<sub>B</sub>,K) ---&gt; Bob (mit K von Alice frisch gewaehlt)

So nur passive Sicherheit: Replay-Angriffe, nicht authentifiziert
PKE-Verfahren IND-CPA &lt;=&gt; Schluesselaustauch passiv sicher


Zusaetzliche Signatur ermoeglicht Authentifikation:
Alice --- C:=Enc(pk<sub>PKE,B</sub>, K), sigma=Sigma(sk<sub>Sig,A</sub>, C)) ---&gt; Bob

Immer noch Replay-Angriffe moeglich",Sicherheit,0
Diffie-Hellman-Schluesselaustauch,"1. Alice --- g<sup>x</sup> ---&gt; Bob
2. Bob --- g<sup>y</sup> ---&gt; Alice
Gemeinsamer Schluessel: K = g<sup>xy</sup>

Passiv sicher, Authentifikation, aber Replay-Angriffe moeglich",Sicherheit,0
Tansport Layer Security (TLS),"Protokoll fuer den Aufbau und Betrieb sicherer Kanaele:
Zuerst authentifizierter asymmetrischer Schluesselaustausch
danach symmetrische Verschluesselung der Nutzdaten
Renegotation (Neuaushandlung des Schluessels) moeglich

Theorem (Hastad und Naeslung):
Sei N, e, d wie bei RSA, M<sup>*</sup> und i in {1, ..., log<sub>2</sub>(N)} beliebig. Sei O ein Orakel, das bei Eingabe C das i-te Bit von M = C<sup>d</sup> mod N ausgibt. Dann existiert ein (von N, e, d unabhaengiger) Polynomial-Algorithmus, der bei Eingabe N, e, i und C<sup>*</sup> := (M<sup>*</sup>)<sup>e</sup> mod N, und mit O-Zugriff M<sup>*</sup> berechnet.",Sicherheit,0
IPsec (Internet Protocol Security),"Aehnlich wie TLS, aber ohne Handshake und auf niedriger Ebene
Schlecht untersucht, aber Angriffe existieren",Sicherheit,0
PK-Identifikationsprotokoll,"(Gen, P, V)
Gen(1<sup>k</sup>) gibt Schluesselpaar (pk, sk) aus
1. V wird mit Eingabe pk gestartet, Ausgabe sei out<sub>V</sub>
2. P wird mit Eingaben sk und out<sub>V</sub> gestartet, Ausgabe out<sub>P</sub>
3. V wird mit Eingabe out<sub>P</sub> gestartet, Ausgabe out<sub>V</sub>
Ist out<sub>V</sub> in {0, 1}, dann beende die Interaktion
Andernfall zurueck zu Schritt 2 (sk-Eingabe nicht mehr noetig)

&lt;P(sk), V(pk)&gt; ist Transkript der Interaktion
V gibt schließlich 1 aus fuer (pk, sk) &lt;- Gen(1<sup>k</sup>)


PK-ID-Protokoll sicher :&lt;=&gt; kein PPT-Angreifer A gewinnt folgendes Spiel mehr als vernachlaessigbar oft:
Phase 1: A darf mit beliebig vielen P-Instanzen (mit sk<sub>i</sub>) in der Rolle des Verifiers V (mit Eingabe pk<sub>i</sub>) interagieren. Die verwendeten (pk<sub>i</sub>, sk<sub>i</sub>) &lt;- Gen(1<sup>k</sup>) sind vom Spiel gewaehlt
Phase 2: A sucht sich ein schon vom Spiel gewaehltes pk<sub>i*</sub> aus und interagiert mit einer V-Instanz (mit Eingabe pk<sub>i*</sub>)
Entscheidung: A gewinnt, wenn V schließlich 1 ausgibt

Intuition: Kein A schafft es, andere zu impersonieren

P &lt;--- R --- V
P --- sigma := Sig(sk<sub>A</sub>, R) ---&gt; V

Sicherheit:
Ist das verwendete Signaturverfahren EUF-CMA-sicher, so ist das PK-ID-Protokoll sicher.",Sicherheit,0
